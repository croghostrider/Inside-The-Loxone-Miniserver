#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Tested with Loxone Miniserver version 10.3.11.27

import struct
import ftplib
import binascii
import StringIO
import sys

loxoneMiniServerIP = '192.168.178.200'  # IP address of the Loxone Miniserver
adminUsername = '<<ADMIN USER>>'
adminPassword = '<<ADMIN PASSWORD>>'

if adminUsername == '<<ADMIN USER>>':
    print("Enter the correct IP addres of your Miniserver, the admin username and password in the script!")
    sys.exit(1)

def RSHash(key):
    # it seems a and b are switched by Loxone
    a = 63689
    hash = 0
    for i in range(len(key)):
        hash = hash * a + ord(key[i])
        hash = hash & 0xFFFFFFFF
        a = a * 378551
    return hash
def JSHash(key):
    hash = 1315423911
    for i in range(len(key)):
        hash ^= (hash >> 2) + ord(key[i]) + (hash * 32)
        hash = hash & 0xFFFFFFFF
    return hash
def DJBHash(key):
    hash = 5381
    for i in range(len(key)):
        hash += hash * 32 + ord(key[i])
        hash = hash & 0xFFFFFFFF
    return hash
def DEKHash(key):
    hash = len(key)
    for i in range(len(key)):
        hash = ((hash << 5) ^ (hash >> 27)) ^ ord(key[i])
        hash = hash & 0xFFFFFFFF
    return hash

ftp = ftplib.FTP(loxoneMiniServerIP)
ftp.login(adminUsername, adminPassword)

ftp.cwd('update')

# get the firmware version number from the first file
version = ftp.nlst()[0].split(' ')[-1].split('_')[0]

# Load DigitalInputTree update into a buffer
sio = StringIO.StringIO()
def handle_binary(more_data):
    sio.write(more_data)
ftp.retrbinary(
    f"RETR {version}_B1E1424BFF667AF471D715EE6745FDF0.upd",
    callback=handle_binary,
)

filedata = sio.getvalue()

ftp.quit()

offset = filedata.rfind(binascii.unhexlify('A55A39')) # first 3 bytes of the master device ID
if offset >= 0:
    filedata = filedata[offset:]
    encryptedAESKey = filedata[12+16*3:12+16*4]
    encryptedAESIV = filedata[12+16*1:12+16*2]
    CryptoCanAlgoKey = [DEKHash(encryptedAESKey), JSHash(encryptedAESKey), DJBHash(encryptedAESKey), RSHash(encryptedAESKey)]
    CryptoCanAlgoIV = [DEKHash(encryptedAESIV), JSHash(encryptedAESIV), DJBHash(encryptedAESIV), RSHash(encryptedAESIV)]

    with open('LoxoneAESKeys.py', 'w') as f:
        f.write('# The AES key/IV is generated by 4 hash functions from this data:\n')
        f.write('LoxoneCryptoEncryptedAESKey = "%s"\n' % binascii.hexlify(encryptedAESKey))
        f.write('LoxoneCryptoEncryptedAESIV = "%s"\n' % binascii.hexlify(encryptedAESIV))
        f.write('\n')
        f.write('LoxoneCryptoCanAlgoLegacyKey = [ %#08x, %#08x, %#08x, %#08x ]\n' % struct.unpack('<LLLL', filedata[12+16*2:12+16*3]))
        f.write('LoxoneCryptoCanAlgoLegacyIV = [ %#08x, %#08x, %#08x, %#08x ]\n' % struct.unpack('<LLLL', filedata[12+16*0:12+16*1]))
        f.write('\n')
        f.write(
            'LoxoneCryptoMasterDeviceID = "%s"\n'
            % binascii.hexlify(filedata[:12])
        )
